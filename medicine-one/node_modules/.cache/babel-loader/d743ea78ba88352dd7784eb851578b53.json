{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar shared = require('@vue/shared');\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\n\nclass EffectScope {\n  constructor(detached = false) {\n    /**\r\n     * @internal\r\n     */\n    this.active = true;\n    /**\r\n     * @internal\r\n     */\n\n    this.effects = [];\n    /**\r\n     * @internal\r\n     */\n\n    this.cleanups = [];\n\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope;\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  run(fn) {\n    if (this.active) {\n      const currentEffectScope = activeEffectScope;\n\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\n\n\n  on() {\n    activeEffectScope = this;\n  }\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\n\n\n  off() {\n    activeEffectScope = this.parent;\n  }\n\n  stop(fromParent) {\n    if (this.active) {\n      let i, l;\n\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      } // nested scope, dereference from parent to avoid memory leaks\n\n\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else {\n    warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);\n  }\n}\n\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\n\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\n\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\n\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    let ptr = 0;\n\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      } // clear bits\n\n\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = new WeakMap(); // The number of effects currently being tracked recursively.\n\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\n\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol('iterate');\nconst MAP_KEY_ITERATE_KEY = Symbol('Map key iterate');\n\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n\n      parent = parent.parent;\n    }\n\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = undefined;\n\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n\n  stop() {\n    // stopped while running itself - defer the cleanup\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n\n      if (this.onStop) {\n        this.onStop();\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n\n    deps.length = 0;\n  }\n}\n\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n\n  const _effect = new ReactiveEffect(fn);\n\n  if (options) {\n    shared.extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n\n  const runner = _effect.run.bind(_effect);\n\n  runner.effect = _effect;\n  return runner;\n}\n\nfunction stop(runner) {\n  runner.effect.stop();\n}\n\nlet shouldTrack = true;\nconst trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n\n    let dep = depsMap.get(key);\n\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n\n    const eventInfo = {\n      effect: activeEffect,\n      target,\n      type,\n      key\n    };\n    trackEffects(dep, eventInfo);\n  }\n}\n\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack = false;\n\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (activeEffect.onTrack) {\n      activeEffect.onTrack({\n        effect: activeEffect,\n        ...debuggerEventExtraInfo\n      });\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n\n  let deps = [];\n\n  if (type === \"clear\"\n  /* TriggerOpTypes.CLEAR */\n  ) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()];\n  } else if (key === 'length' && shared.isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newValue) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    } // also run for iteration key on ADD | DELETE | Map.SET\n\n\n    switch (type) {\n      case \"add\"\n      /* TriggerOpTypes.ADD */\n      :\n        if (!shared.isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (shared.isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (shared.isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n\n        break;\n\n      case \"delete\"\n      /* TriggerOpTypes.DELETE */\n      :\n        if (!shared.isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (shared.isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case \"set\"\n      /* TriggerOpTypes.SET */\n      :\n        if (shared.isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  const eventInfo = {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  };\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      {\n        triggerEffects(deps[0], eventInfo);\n      }\n    }\n  } else {\n    const effects = [];\n\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n\n    {\n      triggerEffects(createDep(effects), eventInfo);\n    }\n  }\n}\n\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  const effects = shared.isArray(dep) ? dep : [...dep];\n\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n}\n\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if (effect.onTrigger) {\n      effect.onTrigger(shared.extend({\n        effect\n      }, debuggerEventExtraInfo));\n    }\n\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/shared.makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /*#__PURE__*/Object.getOwnPropertyNames(Symbol) // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n// but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n// function\n.filter(key => key !== 'arguments' && key !== 'caller').map(key => Symbol[key]).filter(shared.isSymbol));\nconst get = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\"\n        /* TrackOpTypes.GET */\n        , i + '');\n      } // we run the method using the original args first (which may be reactive)\n\n\n      const res = arr[key](...args);\n\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\"\n    /* ReactiveFlags.IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* ReactiveFlags.IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_isShallow\"\n    /* ReactiveFlags.IS_SHALLOW */\n    ) {\n      return shallow;\n    } else if (key === \"__v_raw\"\n    /* ReactiveFlags.RAW */\n    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    const targetIsArray = shared.isArray(target);\n\n    if (!isReadonly && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly) {\n      track(target, \"get\"\n      /* TrackOpTypes.GET */\n      , key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && shared.isIntegerKey(key) ? res : res.value;\n    }\n\n    if (shared.isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nconst set = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\n\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key];\n\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n\n      if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\"\n        /* TriggerOpTypes.ADD */\n        , key, value);\n      } else if (shared.hasChanged(value, oldValue)) {\n        trigger(target, \"set\"\n        /* TriggerOpTypes.SET */\n        , key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  const hadKey = shared.hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, \"delete\"\n    /* TriggerOpTypes.DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n\n  if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\"\n    /* TrackOpTypes.HAS */\n    , key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\"\n  /* TrackOpTypes.ITERATE */\n  , shared.isArray(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nconst mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n\n  set(target, key) {\n    {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n\n};\nconst shallowReactiveHandlers = /*#__PURE__*/shared.extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n}); // Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\n\nconst shallowReadonlyHandlers = /*#__PURE__*/shared.extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nconst toShallow = value => value;\n\nconst getProto = v => Reflect.getPrototypeOf(v);\n\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\"\n      /* TrackOpTypes.GET */\n      , key);\n    }\n\n    track(rawTarget, \"get\"\n    /* TrackOpTypes.GET */\n    , rawKey);\n  }\n\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\n\nfunction has$1(key, isReadonly = false) {\n  const target = this[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\"\n      /* TrackOpTypes.HAS */\n      , key);\n    }\n\n    track(rawTarget, \"has\"\n    /* TrackOpTypes.HAS */\n    , rawKey);\n  }\n\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\"\n  /* TrackOpTypes.ITERATE */\n  , ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\"\n    /* TriggerOpTypes.ADD */\n    , value, value);\n  }\n\n  return this;\n}\n\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get.call(target, key);\n  target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, \"add\"\n    /* TriggerOpTypes.ADD */\n    , key, value);\n  } else if (shared.hasChanged(value, oldValue)) {\n    trigger(target, \"set\"\n    /* TriggerOpTypes.SET */\n    , key, value, oldValue);\n  }\n\n  return this;\n}\n\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions\n\n  const result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, \"delete\"\n    /* TriggerOpTypes.DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target); // forward the operation before queueing reactions\n\n  const result = target.clear();\n\n  if (hadItems) {\n    trigger(target, \"clear\"\n    /* TriggerOpTypes.CLEAR */\n    , undefined, undefined, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"\n    /* ReactiveFlags.RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* TrackOpTypes.ITERATE */\n    , ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"\n    /* ReactiveFlags.RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = shared.isMap(rawTarget);\n    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === 'keys' && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* TrackOpTypes.ITERATE */\n    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\"\n    /* TriggerOpTypes.DELETE */\n    ? false : this;\n  };\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"\n    /* TriggerOpTypes.ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* TriggerOpTypes.SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* TriggerOpTypes.DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* TriggerOpTypes.CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"\n    /* TriggerOpTypes.ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* TriggerOpTypes.SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* TriggerOpTypes.DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* TriggerOpTypes.CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\n\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\"\n    /* ReactiveFlags.IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* ReactiveFlags.IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_raw\"\n    /* ReactiveFlags.RAW */\n    ) {\n      return target;\n    }\n\n    return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nconst mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\n\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = shared.toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1\n      /* TargetType.COMMON */\n      ;\n\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2\n      /* TargetType.COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* TargetType.INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"\n  /* ReactiveFlags.SKIP */\n  ] || !Object.isExtensible(value) ? 0\n  /* TargetType.INVALID */\n  : targetTypeMap(shared.toRawType(value));\n}\n\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\n\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\n\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\n\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!shared.isObject(target)) {\n    {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  } // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n\n\n  if (target[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ] && !(isReadonly && target[\"__v_isReactive\"\n  /* ReactiveFlags.IS_REACTIVE */\n  ])) {\n    return target;\n  } // target already has corresponding Proxy\n\n\n  const existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  } // only specific value types can be observed.\n\n\n  const targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* TargetType.INVALID */\n  ) {\n    return target;\n  }\n\n  const proxy = new Proxy(target, targetType === 2\n  /* TargetType.COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* ReactiveFlags.RAW */\n    ]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"\n  /* ReactiveFlags.IS_REACTIVE */\n  ]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"\n  /* ReactiveFlags.IS_READONLY */\n  ]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"\n  /* ReactiveFlags.IS_SHALLOW */\n  ]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  shared.def(value, \"__v_skip\"\n  /* ReactiveFlags.SKIP */\n  , true);\n  return value;\n}\n\nconst toReactive = value => shared.isObject(value) ? reactive(value) : value;\n\nconst toReadonly = value => shared.isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n    {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: \"get\"\n        /* TrackOpTypes.GET */\n        ,\n        key: 'value'\n      });\n    }\n  }\n}\n\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n\n  if (ref.dep) {\n    {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: \"set\"\n        /* TriggerOpTypes.SET */\n        ,\n        key: 'value',\n        newValue: newVal\n      });\n    }\n  }\n}\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nfunction ref(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n\n    if (shared.hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n\n}\n\nfunction triggerRef(ref) {\n  triggerRefValue(ref, ref.value);\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = undefined;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n\n  get value() {\n    return this._get();\n  }\n\n  set value(newVal) {\n    this._set(newVal);\n  }\n\n}\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (!isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = shared.isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n\n  return ret;\n}\n\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n\n  get value() {\n    const val = this._object[this._key];\n    return val === undefined ? this._defaultValue : val;\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n\n}\n\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a;\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this[_a] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"\n    /* ReactiveFlags.IS_READONLY */\n    ] = isReadonly;\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this);\n    trackRefValue(self);\n\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n\n    return self._value;\n  }\n\n  set value(newValue) {\n    this._setter(newValue);\n  }\n\n}\n\n_a = \"__v_isReadonly\"\n/* ReactiveFlags.IS_READONLY */\n;\n\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = shared.isFunction(getterOrOptions);\n\n  if (onlyGetter) {\n    getter = getterOrOptions;\n\n    setter = () => {\n      console.warn('Write operation failed: computed value is readonly');\n    };\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n\n  if (debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n\n  return cRef;\n}\n\nvar _a$1;\n\nconst tick = /*#__PURE__*/Promise.resolve();\nconst queue = [];\nlet queued = false;\n\nconst scheduler = fn => {\n  queue.push(fn);\n\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\n\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n\n  queue.length = 0;\n  queued = false;\n};\n\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a$1] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n\n            scheduled = false;\n          });\n        } // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n\n\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true\n            /* computedTrigger */\n            );\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n\n  get value() {\n    trackRefValue(this); // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n\n    return toRaw(this)._get();\n  }\n\n}\n\n_a$1 = \"__v_isReadonly\"\n/* ReactiveFlags.IS_READONLY */\n;\n\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexports.EffectScope = EffectScope;\nexports.ITERATE_KEY = ITERATE_KEY;\nexports.ReactiveEffect = ReactiveEffect;\nexports.computed = computed;\nexports.customRef = customRef;\nexports.deferredComputed = deferredComputed;\nexports.effect = effect;\nexports.effectScope = effectScope;\nexports.enableTracking = enableTracking;\nexports.getCurrentScope = getCurrentScope;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.isShallow = isShallow;\nexports.markRaw = markRaw;\nexports.onScopeDispose = onScopeDispose;\nexports.pauseTracking = pauseTracking;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.resetTracking = resetTracking;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.track = track;\nexports.trigger = trigger;\nexports.triggerRef = triggerRef;\nexports.unref = unref;","map":{"version":3,"names":["Object","defineProperty","exports","value","shared","require","warn","msg","args","console","activeEffectScope","EffectScope","constructor","detached","active","effects","cleanups","parent","index","scopes","push","run","fn","currentEffectScope","on","off","stop","fromParent","i","l","length","last","pop","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","undefined","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","options","_effect","extend","lazy","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","key","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","onTrack","trigger","newValue","oldValue","oldTarget","values","isArray","forEach","isMap","isIntegerKey","triggerEffects","computed","triggerEffect","allowRecurse","onTrigger","isNonTrackableKeys","makeMap","builtInSymbols","getOwnPropertyNames","filter","map","isSymbol","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","hasOwn","Reflect","isRef","isObject","readonly","reactive","createSetter","shallowSet","isShallow","hadKey","Number","result","hasChanged","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","get$1","rawTarget","rawKey","wrap","toReadonly","toReactive","call","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","capitalize","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","toRawType","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","def","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","Array","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","defaultValue","_a","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","isFunction","cRef","_a$1","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","e","deferredComputed"],"sources":["/Users/yuchencao/C/CICD Learning/medicineOne/src/main/resources/medioneVUE/medicine-one/node_modules/@vue/reactivity/dist/reactivity.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@vue/shared');\n\nfunction warn(msg, ...args) {\r\n    console.warn(`[Vue warn] ${msg}`, ...args);\r\n}\n\nlet activeEffectScope;\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            const currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else {\r\n            warn(`cannot run an inactive effect scope.`);\r\n        }\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    on() {\r\n        activeEffectScope = this;\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    off() {\r\n        activeEffectScope = this.parent;\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            let i, l;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].stop();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\nfunction recordEffectScope(effect, scope = activeEffectScope) {\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else {\r\n        warn(`onScopeDispose() is called when there is no active effect scope` +\r\n            ` to be associated with.`);\r\n    }\r\n}\n\nconst createDep = (effects) => {\r\n    const dep = new Set(effects);\r\n    dep.w = 0;\r\n    dep.n = 0;\r\n    return dep;\r\n};\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n\nconst targetMap = new WeakMap();\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol('iterate' );\r\nconst MAP_KEY_ITERATE_KEY = Symbol('Map key iterate' );\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        this.parent = undefined;\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        let parent = activeEffect;\r\n        let lastShouldTrack = shouldTrack;\r\n        while (parent) {\r\n            if (parent === this) {\r\n                return;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        try {\r\n            this.parent = activeEffect;\r\n            activeEffect = this;\r\n            shouldTrack = true;\r\n            trackOpBit = 1 << ++effectTrackDepth;\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                initDepMarkers(this);\r\n            }\r\n            else {\r\n                cleanupEffect(this);\r\n            }\r\n            return this.fn();\r\n        }\r\n        finally {\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                finalizeDepMarkers(this);\r\n            }\r\n            trackOpBit = 1 << --effectTrackDepth;\r\n            activeEffect = this.parent;\r\n            shouldTrack = lastShouldTrack;\r\n            this.parent = undefined;\r\n            if (this.deferStop) {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        // stopped while running itself - defer the cleanup\r\n        if (activeEffect === this) {\r\n            this.deferStop = true;\r\n        }\r\n        else if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nfunction effect(fn, options) {\r\n    if (fn.effect) {\r\n        fn = fn.effect.fn;\r\n    }\r\n    const _effect = new ReactiveEffect(fn);\r\n    if (options) {\r\n        shared.extend(_effect, options);\r\n        if (options.scope)\r\n            recordEffectScope(_effect, options.scope);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run();\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nfunction stop(runner) {\r\n    runner.effect.stop();\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (shouldTrack && activeEffect) {\r\n        let depsMap = targetMap.get(target);\r\n        if (!depsMap) {\r\n            targetMap.set(target, (depsMap = new Map()));\r\n        }\r\n        let dep = depsMap.get(key);\r\n        if (!dep) {\r\n            depsMap.set(key, (dep = createDep()));\r\n        }\r\n        const eventInfo = { effect: activeEffect, target, type, key }\r\n            ;\r\n        trackEffects(dep, eventInfo);\r\n    }\r\n}\r\nfunction trackEffects(dep, debuggerEventExtraInfo) {\r\n    let shouldTrack = false;\r\n    if (effectTrackDepth <= maxMarkerBits) {\r\n        if (!newTracked(dep)) {\r\n            dep.n |= trackOpBit; // set newly tracked\r\n            shouldTrack = !wasTracked(dep);\r\n        }\r\n    }\r\n    else {\r\n        // Full cleanup mode.\r\n        shouldTrack = !dep.has(activeEffect);\r\n    }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (activeEffect.onTrack) {\r\n            activeEffect.onTrack({\r\n                effect: activeEffect,\r\n                ...debuggerEventExtraInfo\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    let deps = [];\r\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        deps = [...depsMap.values()];\r\n    }\r\n    else if (key === 'length' && shared.isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* TriggerOpTypes.ADD */:\r\n                if (!shared.isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (shared.isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (shared.isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* TriggerOpTypes.DELETE */:\r\n                if (!shared.isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (shared.isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* TriggerOpTypes.SET */:\r\n                if (shared.isMap(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const eventInfo = { target, type, key, newValue, oldValue, oldTarget }\r\n        ;\r\n    if (deps.length === 1) {\r\n        if (deps[0]) {\r\n            {\r\n                triggerEffects(deps[0], eventInfo);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const effects = [];\r\n        for (const dep of deps) {\r\n            if (dep) {\r\n                effects.push(...dep);\r\n            }\r\n        }\r\n        {\r\n            triggerEffects(createDep(effects), eventInfo);\r\n        }\r\n    }\r\n}\r\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\r\n    // spread into array for stabilization\r\n    const effects = shared.isArray(dep) ? dep : [...dep];\r\n    for (const effect of effects) {\r\n        if (effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n    for (const effect of effects) {\r\n        if (!effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n}\r\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\r\n    if (effect !== activeEffect || effect.allowRecurse) {\r\n        if (effect.onTrigger) {\r\n            effect.onTrigger(shared.extend({ effect }, debuggerEventExtraInfo));\r\n        }\r\n        if (effect.scheduler) {\r\n            effect.scheduler();\r\n        }\r\n        else {\r\n            effect.run();\r\n        }\r\n    }\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ shared.makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(\r\n/*#__PURE__*/\r\nObject.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => Symbol[key])\r\n    .filter(shared.isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\r\n            return shallow;\r\n        }\r\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = shared.isArray(target);\r\n        if (!isReadonly && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - skip unwrap for Array + integer key.\r\n            return targetIsArray && shared.isIntegerKey(key) ? res : res.value;\r\n        }\r\n        if (shared.isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\r\n            return false;\r\n        }\r\n        if (!shallow) {\r\n            if (!isShallow(value) && !isReadonly(value)) {\r\n                oldValue = toRaw(oldValue);\r\n                value = toRaw(value);\r\n            }\r\n            if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = shared.isArray(target) && shared.isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : shared.hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\r\n            }\r\n            else if (shared.hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = shared.hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, shared.isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        {\r\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        {\r\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ shared.extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ shared.extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\r\n        }\r\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\r\n    }\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\r\n        }\r\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\r\n    }\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\r\n    }\r\n    else if (shared.hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = shared.isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        ;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = shared.isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\r\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\r\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(shared.hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = shared.toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* TargetType.COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* TargetType.COLLECTION */;\r\n        default:\r\n            return 0 /* TargetType.INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* TargetType.INVALID */\r\n        : targetTypeMap(shared.toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!shared.isObject(target)) {\r\n        {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only specific value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* TargetType.INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    shared.def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\r\n    return value;\r\n}\r\nconst toReactive = (value) => shared.isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\r\n    if (shouldTrack && activeEffect) {\r\n        ref = toRaw(ref);\r\n        {\r\n            trackEffects(ref.dep || (ref.dep = createDep()), {\r\n                target: ref,\r\n                type: \"get\" /* TrackOpTypes.GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction triggerRefValue(ref, newVal) {\r\n    ref = toRaw(ref);\r\n    if (ref.dep) {\r\n        {\r\n            triggerEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"set\" /* TriggerOpTypes.SET */,\r\n                key: 'value',\r\n                newValue: newVal\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nclass RefImpl {\r\n    constructor(value, __v_isShallow) {\r\n        this.__v_isShallow = __v_isShallow;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._rawValue = __v_isShallow ? value : toRaw(value);\r\n        this._value = __v_isShallow ? value : toReactive(value);\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\r\n        newVal = useDirectValue ? newVal : toRaw(newVal);\r\n        if (shared.hasChanged(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = useDirectValue ? newVal : toReactive(newVal);\r\n            triggerRefValue(this, newVal);\r\n        }\r\n    }\r\n}\r\nfunction triggerRef(ref) {\r\n    triggerRefValue(ref, ref.value );\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (!isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = shared.isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key, _defaultValue) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this._defaultValue = _defaultValue;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        const val = this._object[this._key];\r\n        return val === undefined ? this._defaultValue : val;\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    return isRef(val)\r\n        ? val\r\n        : new ObjectRefImpl(object, key, defaultValue);\r\n}\n\nvar _a;\r\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly, isSSR) {\r\n        this._setter = _setter;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this[_a] = false;\r\n        this._dirty = true;\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if (!this._dirty) {\r\n                this._dirty = true;\r\n                triggerRefValue(this);\r\n            }\r\n        });\r\n        this.effect.computed = this;\r\n        this.effect.active = this._cacheable = !isSSR;\r\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        trackRefValue(self);\r\n        if (self._dirty || !self._cacheable) {\r\n            self._dirty = false;\r\n            self._value = self.effect.run();\r\n        }\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\r\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = shared.isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            ;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\r\n    if (debugOptions && !isSSR) {\r\n        cRef.effect.onTrack = debugOptions.onTrack;\r\n        cRef.effect.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    return cRef;\r\n}\n\nvar _a$1;\r\nconst tick = /*#__PURE__*/ Promise.resolve();\r\nconst queue = [];\r\nlet queued = false;\r\nconst scheduler = (fn) => {\r\n    queue.push(fn);\r\n    if (!queued) {\r\n        queued = true;\r\n        tick.then(flush);\r\n    }\r\n};\r\nconst flush = () => {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]();\r\n    }\r\n    queue.length = 0;\r\n    queued = false;\r\n};\r\nclass DeferredComputedRefImpl {\r\n    constructor(getter) {\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this[_a$1] = true;\r\n        let compareTarget;\r\n        let hasCompareTarget = false;\r\n        let scheduled = false;\r\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\r\n            if (this.dep) {\r\n                if (computedTrigger) {\r\n                    compareTarget = this._value;\r\n                    hasCompareTarget = true;\r\n                }\r\n                else if (!scheduled) {\r\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\r\n                    scheduled = true;\r\n                    hasCompareTarget = false;\r\n                    scheduler(() => {\r\n                        if (this.effect.active && this._get() !== valueToCompare) {\r\n                            triggerRefValue(this);\r\n                        }\r\n                        scheduled = false;\r\n                    });\r\n                }\r\n                // chained upstream computeds are notified synchronously to ensure\r\n                // value invalidation in case of sync access; normal effects are\r\n                // deferred to be triggered in scheduler.\r\n                for (const e of this.dep) {\r\n                    if (e.computed instanceof DeferredComputedRefImpl) {\r\n                        e.scheduler(true /* computedTrigger */);\r\n                    }\r\n                }\r\n            }\r\n            this._dirty = true;\r\n        });\r\n        this.effect.computed = this;\r\n    }\r\n    _get() {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n            return (this._value = this.effect.run());\r\n        }\r\n        return this._value;\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        return toRaw(this)._get();\r\n    }\r\n}\r\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\r\nfunction deferredComputed(getter) {\r\n    return new DeferredComputedRefImpl(getter);\r\n}\n\nexports.EffectScope = EffectScope;\nexports.ITERATE_KEY = ITERATE_KEY;\nexports.ReactiveEffect = ReactiveEffect;\nexports.computed = computed;\nexports.customRef = customRef;\nexports.deferredComputed = deferredComputed;\nexports.effect = effect;\nexports.effectScope = effectScope;\nexports.enableTracking = enableTracking;\nexports.getCurrentScope = getCurrentScope;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.isShallow = isShallow;\nexports.markRaw = markRaw;\nexports.onScopeDispose = onScopeDispose;\nexports.pauseTracking = pauseTracking;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.resetTracking = resetTracking;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.track = track;\nexports.trigger = trigger;\nexports.triggerRef = triggerRef;\nexports.unref = unref;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}